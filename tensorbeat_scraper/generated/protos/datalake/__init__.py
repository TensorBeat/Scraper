# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: datalake.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class GetSongsRequest(betterproto.Message):
    # Pass in map of metadata to be matched on returned songs{"genre":
    # "rock","genre": "metal",}These should be "ORed" so if song matches any of
    # the metadata it is returned
    metadata: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetSongsResponse(betterproto.Message):
    songs: List["_common__.File"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddSongsRequest(betterproto.Message):
    songs: List["_common__.File"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddSongsResponse(betterproto.Message):
    successful: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


class DatalakeServiceStub(betterproto.ServiceStub):
    async def get_songs(self, *, metadata: Dict[str, str] = None) -> "GetSongsResponse":

        request = GetSongsRequest()
        request.metadata = metadata

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/GetSongs", request, GetSongsResponse
        )

    async def add_songs(
        self, *, songs: Optional[List["_common__.File"]] = None
    ) -> "AddSongsResponse":
        songs = songs or []

        request = AddSongsRequest()
        if songs is not None:
            request.songs = songs

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/AddSongs", request, AddSongsResponse
        )


class DatalakeServiceBase(ServiceBase):
    async def get_songs(self, metadata: Dict[str, str]) -> "GetSongsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_songs(
        self, songs: Optional[List["_common__.File"]]
    ) -> "AddSongsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_songs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "metadata": request.metadata,
        }

        response = await self.get_songs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_songs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "songs": request.songs,
        }

        response = await self.add_songs(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/tensorbeat.datalake.DatalakeService/GetSongs": grpclib.const.Handler(
                self.__rpc_get_songs,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSongsRequest,
                GetSongsResponse,
            ),
            "/tensorbeat.datalake.DatalakeService/AddSongs": grpclib.const.Handler(
                self.__rpc_add_songs,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddSongsRequest,
                AddSongsResponse,
            ),
        }


from .. import common as _common__
